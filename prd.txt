# AES-128

## Project Proposal
Implementing AES-128: ECB mode using numpy.

## Program language
Python

## 핵심 기능

최대 2048개의 데이터 블록을 병렬적으로 처리할 수 있는 AES-128 시스템이다.
각 블록의 구조는 다음과 같다
```
Layout (length = 16 * max block):
        [ b0_block0, b0_block1, ..., b0_blockN, 0-pad, ...,   # 0-th byte for every block
          b1_block0, b1_block1, ..., b1_blockN, 0-pad, ...,   # 1-st byte for every block
          ...                                                 # ...
          b15_block0, b15_block1, ..., b15_blockN, 0-pad ...] # 15-th byte for every block
```
이때 각 블록의 한 원소는 4비트로 나뉘어서 총 두 개의 numpy array를 처리하게 된다.

## 데이터 블록 규칙
모든 입력 데이터와 키 블록은 column major 포맷임을 이미 가정합니다. 따라서 어떠한 전치 연산도 필요하지 않습니다.
"""
Return a 1-D NumPy array that stores up to *max_blocks* AES blocks (16-byte each)
    in the layout required by the FHE batching routine.

    Layout (length = 16 * max_blocks):
        [ b0_block0, b0_block1, ..., b0_blockN, 0-pad, ...,   # 0-th byte for every block
          b1_block0, b1_block1, ..., b1_blockN, 0-pad, ...,   # 1-st byte for every block
          ...                                                 # ...
          b15_block0, b15_block1, ..., b15_blockN, 0-pad ...] # 15-th byte for every block

    If the number of provided *blocks* is < *max_blocks*, the remaining entries are
    zero-filled.  If it is greater, a ValueError is raised.

    Parameters
    ----------
    blocks : (N, 16) array-like of uint8
        AES state blocks to pack.  N must be <= *max_blocks*.
    max_blocks : int, optional
        Maximum number of blocks that can be packed (default 2048).

    Returns
    -------
    flat : np.ndarray, shape (16 * max_blocks,), dtype=np.uint8
        Packed 1-D array in row-major order. because we supposed the block is column-major already...
"""

## 키 블록 규칙
모든 입력 데이터와 키 블록은 column major 포맷임을 이미 가정합니다. 따라서 어떠한 전치 연산도 필요하지 않습니다.
"""aes-key-array.py

Utility for constructing a *flat* key array that matches the plaintext layout
used in the AES 2048-block SIMD batching scheme (ECB mode).

Layout recap (length = 16 × max_blocks = 32 768):
    [ k0, k0, … 2048×,   # byte 0 of the key repeated
      k1, k1, … 2048×,   # byte 1 of the key repeated
      …
      k15, k15, … 2048× ]

This allows a single np.bitwise_xor() with the plaintext flat array to apply
AddRoundKey for all blocks simultaneously.
"""

## 프로젝트 구조
```bash
aes-main-process.py
aes-block-array.py
aes-key-array.py
aes-block-array.py
aes-split-to-nibble.py

aes-key-scheduling.py
aes-addroundkey.py
aes-ShiftRows.py
aes-MixColumns.py
aes-SubBytes.py
```

## 제한 사항
numpy.reshape는 모든 aes-operation에서 사용 불가
indexing(ex: [1:4]) 사용 불가
    단, sbox base의 SubBytes계열 함수는 사용가능
